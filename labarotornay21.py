import tkinter as tk  # Импортируем библиотеку tkinter для создания графического интерфейса
from tkinter import scrolledtext  # Импортируем модуль scrolledtext из tkinter для создания поля с прокруткой
import re  # Импортируем модуль re для работы с регулярными выражениями (извлечения слов из текста)
import pymorphy3  # Импортируем библиотеку pymorphy3 для лемматизации (приведения слов к начальной форме)
from collections import Counter  # Импортируем класс Counter из модуля collections для подсчёта частоты слов

morph = pymorphy3.MorphAnalyzer()  # Создаём экземпляр класса MorphAnalyzer для анализа морфологии слов

def count_words():  # Определяем функцию count_words, которая будет выполняться при нажатии кнопки
    text = text_input.get("1.0", tk.END).strip()  # Получаем текст из поля ввода (text_input), удаляем лишние пробелы и переносы строк

    # Извлекаем слова, игнорируем знаки препинания (дополнительно учитываем дефисы в словах)
    words = re.findall(r'[а-яА-ЯёЁ]+(?:-[а-яА-ЯёЁ]+)*', text.lower())  # Используем регулярное выражение для извлечения слов, преобразуем текст в нижний регистр

    # Фильтруем стоп-слова (служебные части речи, которые не несут смысловой нагрузки)
    stop_words = {'в', 'на', 'и', 'а', 'но', 'или', 'бы', 'же', 'то', 'вот', 'это', 'как', 'так', 'что', 'чтобы', 'о', 'об', 'про', 'по', 'за', 'под', 'над', 'до', 'из', 'с', 'к', 'у', 'от', 'для', 'без', 'через', 'между'}  # Задаём набор стоп-слов
    filtered_words = [word for word in words if word not in stop_words]  # Фильтруем список слов, исключая стоп-слова

    cache = {}  # Создаём словарь cache для кэширования результатов лемматизации (чтобы не обрабатывать одно и то же слово несколько раз)
    normalized_words = []  # Создаём список для хранения слов в начальной форме
    for word in filtered_words:  # Проходим по каждому слову из отфильтрованного списка
        if word not in cache:  # Если слово ещё не обработано
            cache[word] = morph.parse(word)[0].normal_form  # Приводим слово к начальной форме с помощью MorphAnalyzer и сохраняем в cache
        normalized_words.append(cache[word])  # Добавляем начальную форму слова в список normalized_words

    # Считаем частоту слов с помощью Counter (удобнее, чем ручной словарь)
    word_count = Counter(normalized_words)  # Создаём объект Counter, который подсчитывает частоту каждого слова

    # Сортируем по частоте (от большей к меньшей)
    sorted_word_count = word_count.most_common()  # Получаем список кортежей (слово, частота) в порядке убывания частоты

    # Формируем результат
    result = ""  # Инициализируем строку для результата
    if sorted_word_count:  # Если есть слова для анализа
        # Самое частое слово
        most_frequent_word, count = sorted_word_count[0]  # Берём первое слово из отсортированного списка (самое частое)
        result += f"Наиболее часто встречающееся слово: {most_frequent_word} — {count} раз\n"  # Формируем строку с самым частым словом

        # Самое редкое слово (из оставшихся после фильтрации)
        least_frequent_word, count = sorted_word_count[-1]  # Берём последнее слово из отсортированного списка (самое редкое)
        result += f"Наиболее редкое слово: {least_frequent_word} — {count} раз"  # Формируем строку с самым редким словом

        # Дополнительно: топ-5 самых частых слов
        top_5 = sorted_word_count[:5]  # Берём первые 5 элементов из отсортированного списка (топ-5 частых слов)
        result += "\n\nТоп-5 самых частых слов:\n"  # Добавляем заголовок для топ-5
        for word, count in top_5:  # Проходим по топ-5 слов
            result += f"{word} — {count} раз\n"  # Формируем строки с каждым словом и его частотой

    text_output.delete("1.0", tk.END)  # Очищаем поле вывода (text_output)
    text_output.insert(tk.END, result)  # Вставляем результат в поле вывода

# Создаём окно
root = tk.Tk()  # Создаём основное окно приложения
root.title("Подсчёт повторяющихся слов")  # Устанавливаем заголовок окна
root.geometry("800x600")  # Устанавливаем размер окна (ширина x высота)
root.resizable(True, True)  # Разрешаем изменение размера окна

# Поле для ввода текста
text_input = scrolledtext.ScrolledText(  # Создаём поле для ввода текста с прокруткой
    root,  # Указываем родительское окно (root)
    width=80,  # Устанавливаем ширину поля
    height=20,  # Устанавливаем высоту поля
    wrap=tk.WORD,  # Включаем перенос по словам
    font=("Arial", 10)  # Устанавливаем шрифт
)
text_input.pack(padx=10, pady=10, fill=tk.BOTH, expand=True)  # Размещаем поле ввода в окне с отступами и возможностью растягивания
text_input.focus()  # Устанавливаем фокус на поле ввода (курсор сразу в поле)

# Кнопка для подсчёта слов
button = tk.Button(  # Создаём кнопку
    root,  # Указываем родительское окно (root)
    text="Подсчитать слова",  # Устанавливаем текст кнопки
    command=count_words,  # Привязываем функцию count_words к нажатию кнопки
    bg="lightblue",  # Устанавливаем цвет фона кнопки
    font=("Arial", 10, "bold")  # Устанавливаем шрифт кнопки
)
button.pack(pady=5, padx=10, fill=tk.X)  # Размещаем кнопку в окне с отступами и растяжкой по горизонтали

# Поле для вывода результата
text_output = scrolledtext.ScrolledText(  # Создаём поле для вывода результата с прокруткой
    root,  # Указываем родительское окно (root)
    width=80,  # Устанавливаем ширину поля
    height=20,  # Устанавливаем высоту поля
    wrap=tk.WORD,  # Включаем перенос по словам
    font=("Arial", 10),  # Устанавливаем шрифт
    fg="blue"  # Устанавливаем цвет текста
)
text_output.pack(padx=10, pady=10, fill=tk.BOTH, expand=True)  # Размещаем поле вывода в окне с отступами и возможностью растягивания

# Добавляем меню для дополнительных настроек (опционально)
menu = tk.Menu(root)  # Создаём меню
root.config(menu=menu)  # Привязываем меню к окну

file_menu = tk.Menu(menu, tearoff=0)  # Создаём подменю "Файл"
file_menu.add_command(label="Очистить поля", command=lambda: text_input.delete("1.0", tk.END))  # Добавляем пункт "Очистить поля" с командой очистки поля ввода
file_menu.add_separator()  # Добавляем разделитель
file_menu.add_command(label="Выход", command=root.quit)  # Добавляем пункт "Выход" с командой закрытия приложения
menu.add_cascade(label="Файл", menu=file_menu)  # Добавляем подменю "Файл" в основное меню

root.mainloop()  # Запускаем основной цикл приложения (ожидание событий)